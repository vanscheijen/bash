#!/bin/bash
#
# (â†„)2012-2014 vanScheijen
#---------------------
# Bash Profiler, prefix your script with this utility and it will give a line
# by line view of the code, possible inputs and count, and timings.
#

set -o nounset

readonly decimals=4
stderr=`mktemp`
proffile="$1"
declare -A lineouts
ptimestamp=""
linecount=0

if ! /bin/bash -n "$@"; then
	echo "Invalid bash script provided"
	exit 1
fi

# Run actual bash script with any arguments provided, and xtrace and extra verbosity
PS4='$(date "+T:%s.%N L:$LINENO + ")' /bin/bash -x "$@" 2> "$stderr"
exitcode=$?

# Parse the verbose stderr output, and make a code profile
while read line; do
	if [[ "$line" =~ ^T:([0-9\.]+)\ L:([0-9]+)\ \+\ (.*)$ ]]; then
		timestamp="${BASH_REMATCH[1]}"
		if [[ -z "$ptimestamp" ]]; then
			timediff=0
			ftimestamp="$timestamp"
		else
			timediff=`echo "$timestamp - $ptimestamp" | bc -l`
			linetime[$plineno]=`echo "${linetime[$plineno]-0} + $timediff" | bc -l`
		fi

		lineno="${BASH_REMATCH[2]}"
		((linecount[$lineno]++))
		lineout="${BASH_REMATCH[3]}"
		((lineouts["$lineno:$lineout"]++))

		ptimestamp="$timestamp"
		plineno="$lineno"
	fi
done < "$stderr"
rm -f "$stderr"

for line in "${!linetime[@]}"; do
	printf "%s\t(%${decimals}d) %0${decimals}d | %s\n" "${linetime[$line]}" "${linecount[$line]}" "$line" "$(sed -n "s/^[ \\t]*//;${line}p;$((line+1))q" "$proffile")"
	for out in "${!lineouts[@]}"; do
		[[ "${out%:*}" == $line ]] && printf "\t\t(%${decimals}d)    - | %s\n" "${lineouts["$out"]}" "${out#*:}"
	done
done

echo -e "$(printf "%.s=" $(seq 1 $(tput cols)))
total time\t: $(echo "$timestamp - $ftimestamp" | bc -l)
exited with\t: $exitcode"

